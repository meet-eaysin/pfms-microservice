import { Injectable, ConflictException } from '@nestjs/common';
import { RegisterUserDto, RegisterUserResponseDto } from '../dtos/register-user.dto';
import { UserRepository, PasswordEncoder, TokenService, SessionRepository } from '../../domain/ports/repositories';
import { EventPublisher } from '../../domain/ports/event-publisher';
import { User, Session } from '../../domain/entities/user.entity';

import { randomUUID } from 'crypto';

@Injectable()
export class RegisterUserUseCase {
  constructor(
    private readonly userRepository: UserRepository,
    private readonly sessionRepository: SessionRepository,
    private readonly passwordEncoder: PasswordEncoder,
    private readonly tokenService: TokenService,
    private readonly eventPublisher: EventPublisher,
    // Injecting interfaces, module will provide implementations
  ) {}

  async execute(dto: RegisterUserDto): Promise<RegisterUserResponseDto> {
    // 1. Check if user exists
    const existingUser = await this.userRepository.findByEmail(dto.email);
    if (existingUser) {
      throw new ConflictException('User with this email already exists');
    }

    // 2. Hash password
    const passwordHash = await this.passwordEncoder.hash(dto.password);

    // 3. Create User
    const newUser = new User(
      '', // ID generated by DB/Repo or we generate here? Repo logic used UUID default.
      // Let's rely on Repo/DB to generate ID or generate it here if Entity requires it.
      // My Entity definition says `id: string`.
      // My PrismaRepo says `id: user.id || undefined`.
      // I'll leave it empty string to indicate "new", or better, generate UUID here to be pure DDD?
      // Prisma `default(uuid())` is eager.
      // I'll pass empty string and let Repo handle it, but then I need the ID back.
      dto.email,
      'user', // default role
      false, // isVerified
      false, // mfaEnabled
      new Date(),
      passwordHash
    );
    
    // Note: Creating user returns the User with ID
    const savedUser = await this.userRepository.create(newUser);

    // 4. Publish UserCreated Event
    await this.eventPublisher.publishUserCreated({
      id: savedUser.id,
      email: savedUser.email,
      firstName: dto.firstName,
      lastName: dto.lastName,
      occurredAt: new Date(),
    });

    // 5. Generate Tokens
    // Access Token payload usually includes sub (userId) and role
    const accessToken = this.tokenService.generateAccessToken({ 
        sub: savedUser.id, 
        email: savedUser.email, 
        role: savedUser.role 
    });
    
    // Refresh Token
    // We need to create a session first?
    // Docs: "refresh_token: TEXT" in sessions table.
    // Register Response: returns refreshToken.
    // Flow: Generate RT -> Create Session -> Return RT.
    // My TokenService generates a JWT for RT as decided.
    const refreshToken = this.tokenService.generateRefreshToken();
    
    // Create Session
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 7); // 7 days

    // We rely on DB to generate ID? 
    // Prisma `default(uuid())` works if we pass undefined.
    // If we want to embed ID in token, we MUST generate it here.
    // Let's use `crypto.randomUUID()` or similar.
    // Assuming Node environment has it.
    const sessionId =  randomUUID();

    const session = new Session(
        sessionId,
        savedUser.id,
        refreshToken,
        expiresAt,
        {} 
    );
    await this.sessionRepository.create(session);

    // 6. Return Response
    return {
      user: {
        id: savedUser.id,
        email: savedUser.email,
      },
      accessToken,
      refreshToken,
    };
  }
}
