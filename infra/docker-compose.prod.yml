include:
  - docker-compose.base.yml

# Production environment with security hardening and optimization
# All ports remain internal-only except Kong Gateway (8000)

services:
  # Note: postgres-* services are defined in docker-compose.base.yml
  # No port overrides in production - all remain internal

  postgres-auth:
    restart: always
    environment:
      POSTGRES_INITDB_ARGS: '-c max_connections=300 -c shared_buffers=256MB -c effective_cache_size=1GB'
    logging:
      driver: json-file
      options:
        max-size: '10m'
        max-file: '3'

  redis:
    restart: always
    command: >
      redis-server
      --appendonly yes
      --requirepass ${REDIS_PASSWORD}
    logging:
      driver: json-file
      options:
        max-size: '10m'
        max-file: '3'

  rabbitmq:
    restart: always
    environment:
      RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER}
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD}
    logging:
      driver: json-file
      options:
        max-size: '10m'
        max-file: '3'

  mongodb:
    restart: always
    logging:
      driver: json-file
      options:
        max-size: '10m'
        max-file: '3'

  minio:
    restart: always
    command: server /data --console-address ":9001" --tls-key-file /etc/minio/certs/private.key --tls-cert-file /etc/minio/certs/public.crt
    logging:
      driver: json-file
      options:
        max-size: '10m'
        max-file: '3'

  prometheus:
    restart: always
    logging:
      driver: json-file
      options:
        max-size: '10m'
        max-file: '3'

  grafana:
    restart: always
    logging:
      driver: json-file
      options:
        max-size: '10m'
        max-file: '3'

  # Kong Gateway Database (PostgreSQL)
  kong-db:
    image: postgres:16-alpine
    container_name: pfms_kong_db
    restart: always
    environment:
      POSTGRES_DB: kong
      POSTGRES_USER: kong
      POSTGRES_PASSWORD: ${KONG_DB_PASSWORD}
    volumes:
      - kong_data:/var/lib/postgresql/data
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U kong']
      interval: 10s
      timeout: 5s
      retries: 5
    logging:
      driver: json-file
      options:
        max-size: '10m'
        max-file: '3'
    networks:
      - pfms_network

  # Kong Gateway - Production with database mode
  kong:
    image: kong:latest
    container_name: pfms_kong
    restart: always
    environment:
      KONG_DATABASE: postgres
      KONG_PG_HOST: kong-db
      KONG_PG_USER: kong
      KONG_PG_PASSWORD: ${KONG_DB_PASSWORD}
      KONG_PROXY_ACCESS_LOG: /dev/stdout
      KONG_ADMIN_ACCESS_LOG: /dev/stdout
      KONG_PROXY_ERROR_LOG: /dev/stderr
      KONG_ADMIN_ERROR_LOG: /dev/stderr
      KONG_ADMIN_LISTEN: 0.0.0.0:8001
      KONG_LOG_LEVEL: notice
    ports:
      - '8000:8000' # Kong Proxy - ONLY public port
    depends_on:
      kong-db:
        condition: service_healthy
    healthcheck:
      test: ['CMD', 'kong', 'health']
      interval: 10s
      timeout: 5s
      retries: 5
    logging:
      driver: json-file
      options:
        max-size: '10m'
        max-file: '3'
    networks:
      - pfms_network

  # Backup service - backs up all databases
  backup:
    image: postgres:16-alpine
    container_name: pfms_backup
    restart: 'no' # Run manually or via cron
    environment:
      PGPASSWORD: postgres
    volumes:
      - ./backups:/backups
    command: |
      sh -c '
        # Backup all per-service databases
        pg_dump -h postgres-auth -U postgres auth_db | gzip > /backups/auth_db_$(date +%Y%m%d_%H%M%S).sql.gz
        pg_dump -h postgres-expense -U postgres expense_db | gzip > /backups/expense_db_$(date +%Y%m%d_%H%M%S).sql.gz
        pg_dump -h postgres-user -U postgres user_db | gzip > /backups/user_db_$(date +%Y%m%d_%H%M%S).sql.gz
        echo "Backup completed at $(date)"
      '
    depends_on:
      - postgres-auth
      - postgres-expense
      - postgres-user
    networks:
      - pfms_network
